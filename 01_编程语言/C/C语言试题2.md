（1）什么是预编译，何时需要预编译： 
答案： 
１、总是使用不经常改动的大型代码体。 
２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。 
（2）char * const p char const * p const char *p 上述三个有什么区别？ 
答案： 
char * const p; //常量指针，p的值不可以修改 
char const * p；//指向常量的指针，指向的常量值不可以改 const char *p； //和char const *p 
（3）char str1[] = "abc"; char str2[] = "abc"; const char str3[] = "abc"; const char str4[] = "abc"; const char *str5 = "abc"; const char *str6 = "abc"; char *str7 = "abc"; char *str8 = "abc"; cout < < ( str1 == str2 ) < < endl; cout < < ( str3 == str4 ) < < endl; cout < < ( str5 == str6 ) < < endl; cout < < ( str7 == str8 ) < < endl; 
结果是：0 0 1 1 str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。 
（4）以下代码中的两个sizeof用法有问题吗？ 
[C易] void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母 { for( size_t i=0; i <sizeof(str)/sizeof(str[0]); ++i ) if( a <=str[i] && str[i] <=z ) str[i] -= (a-A ); } char str[] = "aBcDe"; cout < < "str字符长度为: " < < sizeof(str)/sizeof(str[0]) < < endl; UpperCase( str ); cout < < str < < endl; 答案：函数内的sizeof有问题。根据语法，sizeof如用于数组，只能测出静态数组的大小，无法检测动态分配的或外部数组大小。函数外的str是一个静态定义的数组，因此其大小为6，因为还有\0，函数内的str实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此sizeof作用于上只将其当指针看，一个指针为4个字节，因此返回4。 
（5）一个32位的机器,该机器的指针是多少位答案： 
指针是多少位只要看地址总线的位数就行了。80386以后的机子都是32的数据总线。所以指针的位数就是4个字节了。 
6。main() { int a[5]={1,2,3,4,5}; int *ptr=(int *)(&a+1); printf("%d,%d",*(a+1),*(ptr-1)); } 答案：2。5 *(a+1）就是a[1]，*(ptr-1)就是a[4],执行结果是2，5 &a+1不是首地址+1，系统会认为加一个a数组的偏移，是偏移了一个数组的大小（本例是5个int） int *ptr=(int *)(&a+1); 则ptr实际是&(a[5]),也就是a+5 原因如下： &a是数组指针，其类型为 int (*)[5]; 而指针加1要根据指针类型加上一定的值，不同类型的指针+1之后增加的大小不同 a是长度为5的int数组指针，所以要加 5*sizeof(int) 所以ptr实际是a[5] 但是prt与(&a+1)类型是不一样的(这点很重要) 所以prt-1只会减去sizeof(int*) a,&a的地址是一样的，但意思不一样，a是数组首地址，也就是a[0]的地址，&a是对象（数组）首地址，a+1是数组下一元素的地址，即a[1],&a+1是下一个对象的地址，即a[5]. 
7。请问以下代码有什么问题： int main() { char a; char *str=&a; strcpy(str,"hello"); printf(str); return 0; } 答案：没有为str分配内存空间，将会发生异常问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为越界进行内在读写而导致程序崩溃。 
8。char* s="AAA"; printf("%s",s); s[0]=B; printf("%s",s); 有什么错？答案："AAA"是字符串常量。s是指针，指向这个字符串常量，所以声明s的时候就有问题。 cosnt char* s="AAA"; 然后又因为是常量，所以对是s[0]的赋值操作是不合法的。 
9。写一个“标准”宏，这个宏输入两个参数并返回较小的一个。答案：.#define Min(X, Y) ((X)>(Y)?(Y):(X)) //结尾没有‘；’ 
10。嵌入式系统中经常要用到无限循环，你怎么用C编写死循环。答案：while(1){}或者for(;;) 
11。关键字static的作用是什么？答案：定义静态变量 
12。关键字const有什么含意？答案：表示常量不可以修改的变量。 
13。关键字volatile有什么含意？并举出三个不同的例子？答案：提示编译器对象的值可能在编译器未监测到的情况下改变。 
14。int (*s[10])(int) 表示的是什么啊？答案：int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。 
15。有以下表达式： int a=248; b=4;int const c=21;const int *d=&a; int *const e=&b;int const *f const =&a; 请问下列表达式哪些会被编译器禁止？为什么？答案：*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f; *c 这是个什么东东，禁止 *d 说了是const， 禁止 e = &a 说了是const 禁止 const *f const =&a; 禁止 
16交换两个变量的值，不使用第三个变量。即a=3,b=5,交换之后a=5,b=3; 答案：有两种解法, 一种用算术算法, 一种用^(异或) a = a + b; b = a - b; a = a - b; or a = a^b;// 只能对int,char.. b = a^b; a = a^b; or a ^= b ^= a; 
17.c和c++中的struct有什么不同？答案：c和c++中struct的主要区别是c中的struct不可以含有成员函数，而c++中的struct可以。c++中struct和class的主要区别在于默认的存取权限不同，struct默认为public，而class默认为private 
18.#include <stdio.h> #include <stdlib.h> void getmemory(char *p) { p=(char *) malloc(100); strcpy(p,"hello world"); } int main( ) { char *str=NULL; getmemory(str); printf("%s/n",str); free(str); return 0; } 答案：程序崩溃，getmemory中的malloc 不能返回动态内存， free（）对str操作很危险 
19.char szstr[10]; strcpy(szstr,"0123456789"); 产生什么结果？为什么？答案： 长度不一样，会造成非法的OS 
20.列举几种进程的同步机制，并比较其优缺点。答案： 原子操作 信号量机制 自旋锁 管程，会合，分布式系统 
21.进程之间通信的途径答案：共享存储系统消息传递系统管道：以文件系统为基础 
22.进程死锁的原因答案：资源竞争及进程推进顺序非法 
23.死锁的4个必要条件答案：互斥、请求保持、不可剥夺、环路 
24.死锁的处理答案：鸵鸟策略、预防策略、避免策略、检测与解除死锁 
25. 操作系统中进程调度策略有哪几种？答案：FCFS(先来先服务)，优先级，时间片轮转，多级反馈 
26.类的静态成员和非静态成员有何区别？答案：类的静态成员每个类只有一个，非静态成员每个对象一个 
27.纯虚函数如何定义？使用时应注意什么？答案：virtual void f()=0; 是接口，子类必须要实现 
28.数组和链表的区别答案：数组：数据顺序存储，固定大小连表：数据可以随机存储，大小可动态改变 
29.ISO的七层模型是什么？tcp/udp是属于哪一层？tcp/udp有何优缺点？答案：应用层表示层会话层运输层网络层物理链路层物理层 tcp /udp属于运输层 TCP 服务提供了数据流传输、可靠性、有效流控制、全双工操作和多路复用技术等。与 TCP 不同， UDP 并不提供对 IP 协议的可靠机制、流控制以及错误恢复功能等。由于 UDP 比较简单， UDP 头包含很少的字节，比 TCP 负载消耗少。 tcp: 提供稳定的传输服务，有流量控制，缺点是包头大，冗余性不好 udp: 不提供稳定的服务，包头小，开销小 
30：(void *)ptr 和 (*(void**))ptr的结果是否相同？其中ptr为同一个指针答案：.(void *)ptr 和 (*(void**))ptr值是相同的 
31：int main() { int x=3; printf("%d",x); return 1; } 问函数既然不会被其它函数调用，为什么要返回1？答案：mian中，c标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息 
32，要对绝对地址0x100000赋值，我们可以用 (unsigned int*)0x100000 = 1234; 那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？答案：*((void (*)( ))0x100000 ) ( ); 首先要将0x100000强制转换成函数指针,即: (void (*)())0x100000 然后再调用它: *((void (*)())0x100000)(); 用typedef可以看得更直观些: typedef void(*)() voidFuncPtr; *((voidFuncPtr)0x100000)(); 
33，已知一个数组table，用一个宏定义，求出数据的元素个数答案：#define NTBL #define NTBL (sizeof(table)/sizeof(table[0])) 
34。线程与进程的区别和联系? 线程是否具有相同的堆栈? dll是否有独立的堆栈? 答案：进程是死的，只是一些资源的集合，真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。每个线程有自己的堆栈。 DLL中有没有独立的堆栈，这个问题不好回答，或者说这个问题本身是否有问题。因为DLL中的代码是被某些线程所执行，只有线程拥有堆栈，如果DLL中的代码是EXE中的线程所调用，那么这个时候是不是说这个DLL没有自己独立的堆栈？如果DLL中的代码是由DLL自己创建的线程所执行，那么是不是说DLL有独立的堆栈？以上讲的是堆栈，如果对于堆来说，每个DLL有自己的堆，所以如果是从DLL中动态分配的内存，最好是从DLL中删除，如果你从DLL中分配内存，然后在EXE中，或者另外一个DLL中删除，很有可能导致程序崩溃 
35。unsigned short A = 10; printf("~A = %u\n", ~A); char c=128; printf("c=%d\n",c); 输出多少？并分析过程答案：第一题，～A ＝0xfffffff5,int值 为－11，但输出的是uint。所以输出4294967285 第二题，c＝0x10,输出的是int，最高位为1，是负数，所以它的值就是0x00的补码就是128，所以输出－128。这两道题都是在考察二进制向int或uint转换时的最高位处理。 