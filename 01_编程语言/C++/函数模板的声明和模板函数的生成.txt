函数模板的声明和模板函数的生成

1.1函数模板的声明

函数模板可以用来创建一个通用的函数，以支持多种不同的形参，避免重载函数的函数体重复设计。它的最大特点是把函数使用的数据类型作为参数。

函数模板的声明形式为：

template<typename 数据类型参数标识符>

<返回类型><函数名>(参数表)

{

    函数体

}

其中，template是定义模板函数的关键字；template后面的尖括号不能省略；typename（或class)是声明数据类型参数标识符的关键字，用以说明它后面的标识符是数据类型标识符。这样，在以后定义的这个函数中，凡希望根据实参数据类型来确定数据类型的变量，都可以用数据类型参数标识符来说明，从而使这个变量可以适应不同的数据类型。例如：

template<typename T>

T fuc(T x, int y)

{

    T x;

    //……

}

如果主调函数中有以下语句：

double d;

int a;

fuc(d,a);

则系统将用实参d的数据类型double去代替函数模板中的T生成函数：

double fuc(double x,int y)

{

    double x;

    //……

}

函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。

关键字typename也可以使用关键字class，这时数据类型参数标识符就可以使用所有的C++数据类型。

1.2.模板函数的生成

函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。例如：

使用中应注意的几个问题：

⑴ 函数模板允许使用多个类型参数，但在template定义部分的每个形参前必须有关键字typename或class，即：

template<class 数据类型参数标识符1，…，class 数据类型参数标识符n>

<返回类型><函数名>(参数表)

{

     函数体

}

⑵ 在template语句与函数模板定义语句<返回类型>之间不允许有别的语句。如下面的声明是错误的：

template<class T>

int I;

T min(T x,T y)

{

   函数体

}

⑶ 模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作。




2 函数模板的异常处理



函数模板中的模板形参可实例化为各种类型，但当实例化模板形参的各模板实参之间不完全一致时，就可能发生错误，如：

template<typename T>       

void min(T &x, T &y)

{  return (x<y)?x:y;  }

void func(int i, char j)

{

   min(i, i);

   min(j, j);

   min(i, j);

   min(j, i);

}

例子中的后两个调用是错误的，出现错误的原因是，在调用时，编译器按最先遇到的实参的类型隐含地生成一个模板函数，并用它对所有模板函数进行一致性检查，例如对语句

min(i, j)；

先遇到的实参i是整型的，编译器就将模板形参解释为整型，此后出现的模板实参j不能解释为整型而产生错误，此时没有隐含的类型转换功能。解决此种异常的方法有两种：

⑴采用强制类型转换，如将语句min(i, j);改写为min(i,int( j));

⑵用非模板函数重载函数模板

方法有两种：

① 借用函数模板的函数体

此时只声明非模板函数的原型，它的函数体借用函数模板的函数体。如改写上面的例子如下：

template<typename T>       

void min(T &x, T &y)

{  return (x<y)?x:y;  }

int min(int,int);

void func(int i, char j)

{

   min(i, i);

   min(j, j);

   min(i, j);

   min(j, i);

}

执行该程序就不会出错了，因为重载函数支持数据间的隐式类型转换。

② 重新定义函数体

就像一般的重载函数一样，重新定义一个完整的非模板函数，它所带的参数可以随意。C++中，函数模板与同名的非模板函数重载时，应遵循下列调用原则：

? 寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。

? 寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。

? 若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。

?若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用。



此为转载文章，文章出处没有了。请大家见谅。



