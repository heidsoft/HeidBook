表头文件
     #include<sys/types.h>
     #include<sys/wait.h>
定义函数 pid_t wait (int * status);
函数说明 
    wait()会暂时停止目前进程的执行,直到有信号来到或子进程结
    束。如果在调用 wait()时子进程已经结束,则 wait()会立即返
    回子进程结束状态值。子进程的结束状态值会由参数 status 返回,
    而子进程的进程识别码也会一快返回。如果不在意结束状态值,则
    参数 status 可以设成 NULL。       子进程的结束状态值请参考 waitpid( )     
    如果执行成功则返回子进程识别码(PID)             ,如果有错误发生则返回
返回值
     -1。失败原因存于 errno 中。


     waitpid(等待子进程中断或结束)
表头文件
      #include<sys/types.h>
      #include<sys/wait.h>
定义函数  pid_t waitpid(pid_t pid,int * status,int options);
函数说明
    waitpid()会暂时停止目前进程的执行,直到有信号来到或子进程
    结束。如果在调用 wait()时子进程已经结束,则 wait()会立即
    返回子进程结束状态值。                子进程的结束状态值会由参数 status 返回,
    而子进程的进程识别码也会一快返回。如果不在意结束状态值,则
    参数 status 可以设成 NULL。参数 pid 为欲等待的子进程识别码,
    其他数值意义如下:
    pid<-1 等待进程组识别码为 pid 绝对值的任何子进程。
    pid=-1 等待任何子进程,相当于 wait()。            
    pid=0     等待进程组识别码与目前进程相同的任何子进程。       
    pid>0     等待任何子进程识别码为 pid 的子进程。
    参数 option 可以为 0 或下面的 OR 组合:
    WNOHANG 如果没有任何已经结束的子进程则马上返回, 不予以等待。
    WUNTRACED 如果子进程进入暂停执行情况则马上返回,但结束状态不予以理会。
    子进程的结束状态返回后存于 status,底下有几个宏可判别结束情况:
    WIFEXITED(status)如果子进程正常结束则为非 0 值。
    WEXITSTATUS(status)取得子进程 exit()返回的结束代码,一般会先用 WIFEXITED 来判断是否正常结束才能使用此宏。
    WIFSIGNALED(status)如果子进程是因为信号而结束则此宏值为真
    WTERMSIG(status) 取得子进程因信号而中止的信号代码,一般会先用 WIFSIGNALED 来判断后才使用此宏。
    WIFSTOPPED(status) 如果子进程处于暂停执行情况则此宏值为真。一般只有使用 WUNTRACED 时才会有此情况。
    WSTOPSIG(status) 取得引发子进程暂停的信号代码,一般会先用 WIFSTOPPED 来判断后才使用此宏。
    如果执行成功则返回子进程识别码(PID)         ,如果有错误发生则返回
返回值
    -1。失败原因存于 errno 中。
    
    
/******
*    waitpid.c - Simple wait usage
*********/

#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main( void )
{
    pid_t childpid;
    int status;
    
    childpid = fork();
    
    if ( -1 == childpid )
    {
        perror( "fork()" );
        exit( EXIT_FAILURE );
    }
    else if ( 0 == childpid )
    {
        puts( "In child process" );
        sleep( 3 );//让子进程睡眠3秒，看看父进程的行为
        printf("\tchild pid = %d\n", getpid());
        printf("\tchild ppid = %d\n", getppid());
        exit(EXIT_SUCCESS);
    }
    else 
    {
        waitpid( childpid, &status, 0 );
        puts( "in parent" );
        printf( "\tparent pid = %d\n", getpid() );
        printf( "\tparent ppid = %d\n", getppid()  );
        printf( "\tchild process exited with status %d \n", status );
    }
    exit(EXIT_SUCCESS);
}

[root@localhost src]# gcc waitpid.c 
[root@localhost src]# ./a.out 
In child process
        child pid = 4469
        child ppid = 4468
in parent
        parent pid = 4468
        parent ppid = 4379
        child process exited with status 0 
[root@localhost src]# 

如果将上面“waitpid( childpid, &status, 0 );”行注释掉，程序执行效果如下：
[root@localhost src]# ./a.out 
In child process
in parent
        parent pid = 4481
        parent ppid = 4379
        child process exited with status 1331234400 
[root@localhost src]#   child pid = 4482
        child ppid = 1

子进程还没有退出，父进程已经退出了。